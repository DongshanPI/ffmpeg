diff --git a/interface/include/vdec/mi_vdec.h b/interface/include/vdec/mi_vdec.h
index 89056ec..c4b93e0 100755
--- a/interface/include/vdec/mi_vdec.h
+++ b/interface/include/vdec/mi_vdec.h
@@ -96,6 +96,7 @@ MI_S32 MI_VDEC_ResetChn(MI_VDEC_CHN VdecChn);
 MI_S32 MI_VDEC_SetChnParam(MI_VDEC_CHN VdecChn, MI_VDEC_ChnParam_t *pstChnParam);
 MI_S32 MI_VDEC_GetChnParam(MI_VDEC_CHN VdecChn, MI_VDEC_ChnParam_t *pstChnParam);
 MI_S32 MI_VDEC_SendStream(MI_VDEC_CHN VdecChn, MI_VDEC_VideoStream_t *pstVideoStream, MI_S32 s32MilliSec);
+MI_S32 MI_VDEC_SendStream_FF(MI_VDEC_CHN VdecChn, MI_VDEC_VideoStream_t *pstVideoStream, MI_S32 s32MilliSec);
 MI_S32 MI_VDEC_GetUserData(MI_VDEC_CHN VdecChn, MI_VDEC_UserData_t *pstUserData, MI_S32 s32MilliSec);
 MI_S32 MI_VDEC_ReleaseUserData(MI_VDEC_CHN VdecChn, MI_VDEC_UserData_t *pstUserData);
 MI_S32 MI_VDEC_SetDisplayMode(MI_VDEC_CHN VdecChn, MI_VDEC_DisplayMode_e eDisplayMode);
diff --git a/interface/src/vdec/vdec_api.c b/interface/src/vdec/vdec_api.c
index f8c3340..b0bdc37 100755
--- a/interface/src/vdec/vdec_api.c
+++ b/interface/src/vdec/vdec_api.c
@@ -304,6 +304,64 @@ MI_S32 MI_VDEC_GetChnParam(MI_VDEC_CHN VdecChn, MI_VDEC_ChnParam_t *pstChnParam)
     return s32Ret;
 }
 
+static MI_S32 _MI_VDEC_SendFrame_FF(MI_VDEC_CHN VdecChn, MI_VDEC_VideoStream_t *pstVideoStream, MI_S32 s32MilliSec)
+{
+    MI_S32 s32Ret = E_MI_ERR_FAILED;
+    MI_SYS_ChnPort_t stChnPort;
+    MI_SYS_BufConf_t stBufCfg;
+    MI_SYS_BufInfo_t stBufInfo;
+    MI_SYS_BUF_HANDLE hBufHandle = MI_HANDLE_NULL;
+    MI_BOOL bHaveStartCode = TRUE;
+
+    stChnPort.eModId = E_MI_MODULE_ID_VDEC;
+    stChnPort.u32DevId = 0;
+    stChnPort.u32ChnId = VdecChn;
+    stChnPort.u32PortId = 0;
+
+    stBufCfg.eBufType = E_MI_SYS_BUFDATA_RAW;
+    stBufCfg.u64TargetPts = MI_SYS_INVALID_PTS;
+    
+    if(pstVideoStream->pu8Addr[0] != 0 || pstVideoStream->pu8Addr[1] != 0 ||    \
+        pstVideoStream->pu8Addr[2] != 0 || pstVideoStream->pu8Addr[3] != 1)
+    {
+        bHaveStartCode = FALSE;
+    }
+    if(bHaveStartCode)
+        stBufCfg.stRawCfg.u32Size = pstVideoStream->u32Len;
+    else
+        stBufCfg.stRawCfg.u32Size = pstVideoStream->u32Len + 4;//add start code
+
+    s32Ret = MI_SYS_ChnInputPortGetBuf(&stChnPort, &stBufCfg, &stBufInfo, &hBufHandle, s32MilliSec);
+    if (MI_SUCCESS != s32Ret)
+    {
+        return s32Ret;
+    }
+
+    if (stBufInfo.stRawData.u32BufSize < stBufCfg.stRawCfg.u32Size)
+    {
+        MI_SYS_ChnInputPortPutBuf(hBufHandle, &stBufInfo, TRUE);
+        DBG_ERR("Get Buffer Error, Size Error\n");
+        return E_MI_ERR_FAILED;
+    }
+
+    stBufInfo.u64Pts = pstVideoStream->u64PTS;
+    stBufInfo.stRawData.u32ContentSize = stBufCfg.stRawCfg.u32Size;
+    if(!bHaveStartCode)
+    {
+        char start_code[]= {0,0,0,1};
+        memcpy(stBufInfo.stRawData.pVirAddr,start_code,sizeof(start_code));
+        memcpy(stBufInfo.stRawData.pVirAddr + 4, pstVideoStream->pu8Addr, pstVideoStream->u32Len);
+    }
+    else
+    {
+        memcpy(stBufInfo.stRawData.pVirAddr, pstVideoStream->pu8Addr, pstVideoStream->u32Len);
+    }
+
+    s32Ret = MI_SYS_ChnInputPortPutBuf(hBufHandle, &stBufInfo, FALSE);
+    return s32Ret;
+}
+
+
 static MI_S32 _MI_VDEC_SendFrame(MI_VDEC_CHN VdecChn, MI_VDEC_VideoStream_t *pstVideoStream, MI_S32 s32MilliSec)
 {
     MI_S32 s32Ret = E_MI_ERR_FAILED;
@@ -350,6 +408,145 @@ static void _MI_VDEC_ForceToPanic(void)
     }
 }
 
+MI_S32 MI_VDEC_SendStream_FF(MI_VDEC_CHN VdecChn, MI_VDEC_VideoStream_t *pstVideoStream, MI_S32 s32MilliSec)
+{
+    MI_S32 s32Ret = E_MI_ERR_FAILED;
+
+    if (!pstVideoStream)
+    {
+        return s32Ret;
+    }
+
+    if (!pstVideoStream->u32Len)
+    {
+        return s32Ret;
+    }
+
+    if (   (_astFramingParams[VdecChn].pu8FramingBuf)
+        && (E_MI_VDEC_VIDEO_MODE_STREAM == _astFramingParams[VdecChn].eVideoMode))
+    {
+        ///stream mode
+        MI_U32 u32FrmBound = 0;
+        MI_U32 u32SendByte = 0;
+        MI_U8 *pu8CurPos = NULL;
+        MI_VDEC_VideoStream_t stVideoStream;
+        MI_S64 s64RemainLen = 0;
+        MI_U8 bBoundAlignStart = FALSE;
+
+        if (_astFramingParams[VdecChn].u32RemainSize)
+        {
+            MI_U32 u32CopyLen = 0;
+            u32CopyLen = _astFramingParams[VdecChn].u32FramingBufSize - _astFramingParams[VdecChn].u32RemainSize;
+            if (!u32CopyLen)
+            {
+                _MI_VDEC_ForceToPanic();
+            }
+
+            u32CopyLen = (u32CopyLen > pstVideoStream->u32Len) ? pstVideoStream->u32Len : u32CopyLen;
+            memcpy(_astFramingParams[VdecChn].pu8FramingBuf + _astFramingParams[VdecChn].u32RemainSize, pstVideoStream->pu8Addr, u32CopyLen);
+            pu8CurPos = _astFramingParams[VdecChn].pu8FramingBuf;
+        }
+
+        s64RemainLen = pstVideoStream->u32Len + _astFramingParams[VdecChn].u32RemainSize;
+        while (s64RemainLen > 0)
+        {
+            if (!_astFramingParams[VdecChn].bStart)
+            {
+                ///chn close
+                _astFramingParams[VdecChn].u32RemainSize = 0;
+                return s32Ret;
+            }
+
+            if (u32SendByte >= _astFramingParams[VdecChn].u32RemainSize)
+            {
+                pu8CurPos = pstVideoStream->pu8Addr + (u32SendByte - _astFramingParams[VdecChn].u32RemainSize);
+            }
+
+            u32FrmBound = get_next_frame_start_position(pu8CurPos, (unsigned int)s64RemainLen, _astFramingParams[VdecChn].eCodecType, &bBoundAlignStart);
+            if (u32FrmBound)
+            {
+                stVideoStream.u64PTS = pstVideoStream->u64PTS;
+                stVideoStream.bEndOfFrame = TRUE;
+                stVideoStream.bEndOfStream = TRUE;
+                stVideoStream.pu8Addr = pu8CurPos;
+                stVideoStream.u32Len = u32FrmBound;
+                if (bBoundAlignStart)
+                {
+                    s32Ret = _MI_VDEC_SendFrame_FF(VdecChn, &stVideoStream, s32MilliSec);
+                }
+                else
+                {
+                    DBG_ERR("Chn(%d), Start Pos Not Aligned Bound, Drop\n", VdecChn, _astFramingParams[VdecChn].eCodecType);
+                }
+
+                if ((MI_SUCCESS == s32Ret) || (!bBoundAlignStart))
+                {
+                    pu8CurPos += u32FrmBound;
+                    u32SendByte += u32FrmBound;
+                    s64RemainLen -= u32FrmBound;
+                    continue;
+                }
+            }
+
+
+            if (s64RemainLen >= _astFramingParams[VdecChn].u32FramingBufSize)
+            {
+                if (!u32FrmBound)
+                {
+                    DBG_ERR("Framing Buffer Small, And Frame UnFound, Need To Panic\n");
+                    _MI_VDEC_ForceToPanic();
+                }
+
+                DBG_WRN("Framing Buffer Small, Need To Try Send Frame\n");
+                s32MilliSec = 30;
+                continue;
+            }
+
+            ///goto return;
+            if (s64RemainLen <= 0)
+            {
+                return s32Ret;
+            }
+
+            if (u32SendByte >= _astFramingParams[VdecChn].u32RemainSize)
+            {
+                ///copy from pstVideoStream->pu8Addr
+                memcpy(_astFramingParams[VdecChn].pu8FramingBuf, pu8CurPos, s64RemainLen);
+                _astFramingParams[VdecChn].u32RemainSize = s64RemainLen;
+            }
+            else
+            {
+                ///copy from _astFramingParams
+                MI_U8 *pu8TmpBuf = NULL;
+                MI_U32 u32FrmingBufLen = 0;
+
+                pu8TmpBuf = (MI_U8 *)malloc(s64RemainLen);
+                if (!pu8TmpBuf)
+                {
+                    DBG_ERR("Buffer Malloc Error\n");
+                    return s32Ret;
+                }
+
+                u32FrmingBufLen = _astFramingParams[VdecChn].u32RemainSize - u32SendByte;
+                memcpy(pu8TmpBuf, pu8CurPos, u32FrmingBufLen);
+                memcpy(pu8TmpBuf + u32FrmingBufLen, pstVideoStream->pu8Addr, s64RemainLen - u32FrmingBufLen);
+                memcpy(_astFramingParams[VdecChn].pu8FramingBuf, pu8TmpBuf, s64RemainLen);
+                _astFramingParams[VdecChn].u32RemainSize = s64RemainLen;
+                free(pu8TmpBuf);
+                pu8TmpBuf = NULL;
+            }
+            return MI_SUCCESS;
+        }
+    }
+    else
+    {
+        ///frame mode
+        s32Ret = _MI_VDEC_SendFrame_FF(VdecChn, pstVideoStream, s32MilliSec);
+    }
+
+    return s32Ret;
+}
+
 MI_S32 MI_VDEC_SendStream(MI_VDEC_CHN VdecChn, MI_VDEC_VideoStream_t *pstVideoStream, MI_S32 s32MilliSec)
 {
     MI_S32 s32Ret = E_MI_ERR_FAILED;
